<!--

Aula 23 - Projeto Final: Componente Filtro (Slider)

Nesta aula iremos fazer o funcionamento do bot√£o de filtro.

Passo 1 - Estrutura inicial do bot√£o de filtro

Inicialmente o bot√£o de filtro se encontra assim:

<div className='col-sm-1'>
  Aqui filtro
</div>


Agora, dentro dessa div, vamos adicionar um button.
Nesse bot√£o iremos atribuir propriedades do Bootstrap que permitem abrir um modal:

data-bs-toggle='modal'

data-bs-target='#filterModal'

Exemplo:

<div className='col-sm-1'>
  <button data-bs-toggle='modal' data-bs-target='#filterModal'>
    Filtros
  </button>
</div>

Passo 2 - √çcone no bot√£o de filtro

Tamb√©m usamos um √≠cone para o filtro, utilizando a tag <i>.

Exemplo:

<button 
  className='btn btn-filtro d-flex float-end' 
  data-bs-toggle='modal' 
  data-bs-target='#filterModal'
>
  <i className='mdi mdi-filter-variant'></i>
  Filtro
</button>


Esse √≠cone pegamos do Material Design Icons, como explicado anteriormente.

Passo 3 - Criando o componente ModalFilter

Para o modal do filtro aparecer, criamos um componente chamado ModalFilter.jsx que conter√° o modal do Bootstrap.
Quando o bot√£o for clicado, ele exibir√° esse componente.

O modal foi copiado da documenta√ß√£o oficial do Bootstrap (se√ß√£o Modal).
Exemplo da base:

<div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="exampleModalLabel">Modal title</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        ...
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary">Save changes</button>
      </div>
    </div>
  </div>
</div>


Nosso componente ModalFilter.jsx ficou assim:

import React from 'react'

export default function ModalFilter() {
  return (
    <div className="modal fade" id="filterModal" tabIndex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div className="modal-dialog">
        <div className="modal-content">
          <div className="modal-header">
            <h1 className="modal-title fs-5" id="exampleModalLabel">Modal title</h1>
            <button type="button" className="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div className="modal-body">
            ...
          </div>
          <div className="modal-footer">
            <button type="button" className="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            <button type="button" className="btn btn-primary">Save changes</button>
          </div>
        </div>
      </div>
    </div>
  )
}


üìå Detalhe importante:
Na div principal, usamos o ID filterModal:

<div className="modal fade" id="filterModal">


Esse mesmo nome √© o que foi passado no data-bs-target do bot√£o.
Por isso, ao clicar no bot√£o, o Bootstrap consegue abrir automaticamente o modal correspondente, pois ele associa o data-bs-target ao id do modal.

Passo 4 - Importando o modal no App.jsx

Para o modal funcionar, precisamos import√°-lo no componente principal (App.jsx).
Dessa forma:

// importar modal de filtro
import ModalFilter from './components/ModalFilter';

function App() {
  return (
    <div>
      <Navbar />
      <Categorias />
      <ModalFilter />
    </div>
  )
}


Pronto ‚úÖ
Agora, com o componente modal j√° importado, ele aparece normalmente ao clicar no bot√£o de filtro.

üìå Isso funciona porque o Bootstrap trabalha com data attributes (ex: data-bs-toggle, data-bs-target), que s√£o ligados ao id do modal.
Quando clicamos no bot√£o, o Bootstrap identifica o data-bs-target="#filterModal" e procura no DOM por um modal com esse id.
Assim, mesmo sem c√≥digo adicional em React, o Bootstrap abre e fecha o modal automaticamente.

Passo 5 - Adicionando conte√∫do ao modal

Agora s√≥ falta dar conte√∫do ao modal.

Dentro desse conte√∫do, teremos uma parte que precisa de um componente separado chamado PriceSlider.jsx.

Criando o PriceSlider (slider de pre√ßos)

O PriceSlider √© basicamente a barra que movimentamos para filtrar os valores de pre√ßo.
Criamos esse componente separado porque:

Mant√©m o projeto mais organizado.

D√° maior controle de manipula√ß√£o (categoria, pre√ßo m√≠nimo, pre√ßo m√°ximo).

Pode ser reutilizado em outros projetos.

√â um dos filtros mais comuns em sistemas de e-commerce.

(‚Äúprice‚Äù significa pre√ßo em ingl√™s, e ‚Äúslider‚Äù √© algo que desliza).

Estrutura do PriceSlider

O PriceSlider √© composto por 4 elementos principais:

Slider ‚Üí A barra cinza clara (fundo da faixa).

Progress ‚Üí A barra mais escura que acompanha os movimentos.

Range Min ‚Üí Input que controla o valor m√≠nimo.

Range Max ‚Üí Input que controla o valor m√°ximo.

Com CSS, juntamos esses elementos para parecer um √∫nico componente.
E com useState, controlamos os valores e movimenta√ß√£o.

Passo 1 - Criando a parte est√©tica

Primeiro, importamos o CSS do slider no componente:

import './css/priceSlider.css'


E criamos a estrutura inicial:

import React from 'react'
import './css/priceSlider.css'

export default function PriceSlider() {
  return (
    <div>
      <div className='slider'></div>
    </div>
  )
}

CSS inicial
.slider {
  display: flex;
  position: relative;
  height: 5px;
  background: #ddd;
  border-radius: 5px;
}


üëâ Esse CSS cria uma barra cinza fina que servir√° como trilho para o slider.

display: flex ‚Üí Permite posicionar elementos dentro dela.

position: relative ‚Üí Necess√°rio para que os elementos internos (progress e inputs) usem absolute em rela√ß√£o a ela.

height: 5px ‚Üí Define a espessura da barra.

background: #ddd ‚Üí D√° a cor cinza clara.

border-radius: 5px ‚Üí Deixa as pontas levemente arredondadas.

Passo 2 - Criando a barra de progresso

Dentro da div slider, criamos outra div chamada progress:

export default function PriceSlider() {
  return (
    <div>
      <div className='slider'>
        <div className='progress'></div>
      </div>
    </div>
  )
}

CSS da progress
.slider .progress {
  height: 100%;
  position: absolute;
  /* left: 5%;
  right: 30%; */
  background: #464646;
}


üëâ Explica√ß√£o:

position: absolute ‚Üí Faz a barra se posicionar por cima do slider.

Se definirmos left: 5% e right: 30%, a progress fica apenas entre esses dois pontos, simulando o intervalo selecionado.

background: #464646 ‚Üí Torna a barra mais escura.

Assim, conforme alteramos os valores m√≠nimo e m√°ximo, a barra de progresso vai se ajustando dinamicamente.

Passo 3 - Criando os inputs range (bolinhas)

Agora precisamos das bolinhas que o usu√°rio move para alterar o pre√ßo.

Para isso, usamos inputs do tipo range (aquele mesmo usado para volume de √°udio).

Dentro da div slider, criamos outra div chamada range-input que conter√° dois inputs:

export default function PriceSlider() {
  return (
    <div>
      <div className='slider'>
        <div className='progress'></div>
        <div className='range-input'>
          <input id='rangeMin' type='range' />  
          <input id='rangeMax' type='range' />  
        </div>
      </div>
    </div>
  )
}

Passo 4 - Estilizando os inputs (truque das bolinhas)

A ideia √© esconder a barra original do input e deixar s√≥ as bolinhas vis√≠veis.

CSS
.range-input {
  position: relative;
}

.range-input input {
  width: 100%;
  position: absolute;
  height: 5px;
  top: -5px;
  background: none;
  pointer-events: none;
  -webkit-appearance: none;
  -moz-appearance: none;
}


üëâ Explica√ß√£o:
Os campos do tipo input (do tipo range) ter√£o uma position: absolute, o que faz com que os dois inputs fiquem um em cima do outro, no mesmo lugar.
Assim, conseguimos ter apenas duas bolinhas de movimenta√ß√£o, mas escondendo a barra padr√£o dos inputs.

Retirando o estilo padr√£o dos inputs

Usamos background: none; para remover o fundo.

Aplicamos o -webkit-appearance: none;. Esse atributo for√ßa o navegador (no caso do Chrome, Safari e derivados) a remover o estilo padr√£o do campo range.

Tamb√©m aplicamos o -moz-appearance: none; que faz a mesma coisa, mas no Firefox.

Com isso, a barra padr√£o do input desaparece, ficando apenas as bolinhas de movimenta√ß√£o.

Ajustando o tamanho e alinhamento

Definimos width: 100% para que os inputs cubram todo o espa√ßo dispon√≠vel.

Usamos height: 5px, mesma altura do nosso slider, para alinhar corretamente os elementos.

Com top: -5px, ajustamos a posi√ß√£o absoluta para que as bolinhas fiquem exatamente sobre a barra do slider.

Controlando o comportamento dos inputs

Aplicamos pointer-events: none;.
Isso significa que o usu√°rio n√£o pode interagir diretamente com os inputs.
Na pr√°tica, quem controla o movimento das bolinhas √© a nossa barra de progresso (.progress).
Assim, quando a barra de progresso desliza, as bolinhas deslizam junto de forma sincronizada.9











üé® Estilizando as bolinhas do slider

Agora iremos modificar a apar√™ncia das bolinhas dos inputs range.

No CSS, trabalhamos diretamente com o seletor do tipo range, mas para alterar somente as bolinhas, usamos os seletores especiais:

::-webkit-slider-thumb ‚Üí funciona para navegadores baseados no Webkit (Chrome, Safari, Edge).

::-moz-range-thumb ‚Üí funciona para o Firefox.

Exemplo no Chrome (Webkit):

input[type="range"]::-webkit-slider-thumb {
    width: 30px;
    height: 30px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 50%;
    box-shadow: 0 0 6px rgba(0,0,0,0.05);
    pointer-events: auto;
    -webkit-appearance: none;
}


üëâ Explicando cada linha:

width: 30px; height: 30px; ‚Üí define o tamanho da bolinha.

background: white; ‚Üí deixa a bolinha branca.

-webkit-appearance: none; ‚Üí remove o estilo padr√£o do navegador, garantindo que o fundo branco apare√ßa corretamente.

border: 1px solid #ccc; ‚Üí adiciona uma borda cinza clara para dar contraste.

border-radius: 50%; ‚Üí deixa a bolinha totalmente redonda.

box-shadow: 0 0 6px rgba(0,0,0,0.05); ‚Üí adiciona uma leve sombra.

pointer-events: auto; ‚Üí reativa os eventos de clique/movimento (lembre que t√≠nhamos desativado no input).

No Firefox, copiamos o mesmo c√≥digo, apenas trocando por ::-moz-range-thumb e -moz-appearance: none;:

input[type="range"]::-moz-range-thumb {
    width: 30px;
    height: 30px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 50%;
    box-shadow: 0 0 6px rgba(0,0,0,0.05);
    pointer-events: auto;
    -moz-appearance: none;
}


‚úÖ Pronto! Agora temos bolinhas personalizadas e funcionando em qualquer navegador.

üí∞ Criando os campos de pre√ßo m√≠nimo e m√°ximo

Ainda no nosso componente PriceSlider, logo abaixo dos ranges, vamos criar os campos para exibir e editar o pre√ßo m√≠nimo e m√°ximo.

Fizemos isso com Bootstrap Input Groups (pegos direto na documenta√ß√£o oficial).

üìå Exemplo do pre√ßo m√≠nimo:

<div className='row mt-4'>
  <div className='col'>
    <label className='text-muted'>Pre√ßo m√≠nimo</label>
    <div className="input-group mb-3">
      <span className="input-group-text" id="basic-addon1">R$</span>
      <input id="inputMin" type="text" className="form-control" placeholder="Min" />
    </div>
  </div>
</div>


üìå Exemplo do pre√ßo m√°ximo:

<div className='col'>
  <label className='text-muted'>Pre√ßo m√°ximo</label>
  <div className="input-group mb-3">
    <span className="input-group-text" id="basic-addon1">R$</span>
    <input id="inputMax" type="text" className="form-control" placeholder="Max" />
  </div>
</div>


‚û°Ô∏è A diferen√ßa est√° apenas no id (inputMax), no texto do label (‚ÄúPre√ßo m√°ximo‚Äù) e no placeholder (‚ÄúMax‚Äù).

üé® Finalizando a parte est√©tica

At√© aqui, terminamos toda a estiliza√ß√£o do nosso filtro:

Barra cinza (slider).

Barra de progresso escura.

Bolinhas estilizadas.

Campos para pre√ßo m√≠nimo e m√°ximo.

Agora vamos para a parte mais importante: a l√≥gica, para que tudo realmente funcione.

‚öôÔ∏è Controlando os valores com useState e props

Para controlar os valores do m√≠nimo, m√°ximo e a posi√ß√£o da barra de progresso, usamos o estado do React (useState).

Al√©m disso, tamb√©m precisamos de alguns atributos do campo range:

min ‚Üí valor m√≠nimo que o slider pode assumir.

max ‚Üí valor m√°ximo.

value ‚Üí valor atual do slider.

step ‚Üí define os passos do movimento (exemplo: 1 movimenta de 1 em 1).

üìå Exemplo do nosso input configurado:

<input 
  id='rangeMin' 
  type="range" 
  min='50' 
  max='2000' 
  step='1' 
/>

Passando valores din√¢micos via props

At√© aqui, definimos valores fixos para os atributos min, max e step dos nossos inputs do tipo range.
Agora vamos deixar isso din√¢mico com o uso dos props, assim o PriceSlider pode ser reutilizado em qualquer lugar do sistema recebendo os valores que quisermos.

No componente pai (ModalFilter por exemplo), passamos os valores:

<PriceSlider min={50} max={2000} step={1} />


E no componente PriceSlider, recebemos esses props:

export default function PriceSlider(props) {
    return (
        <div className='range-input'>
            <input id='rangeMin' type="range" min={props.min} max={props.max} step={props.step} />
            <input id='rangeMax' type="range" min={props.min} max={props.max} step={props.step} />
        </div>
    )
}


‚úÖ Dessa forma, os valores n√£o ficam mais ‚Äúengessados‚Äù e podemos alterar a faixa de pre√ßo apenas mudando os props do componente. 













Aula 23 - Projeto Final Componente Filtro (Slider)
nessa aula iremos fazer o funcionamento do bot√£o de fltro, inicialmente ele se encontr adessa forma: 
<div className='col-sm-1'>
                    Aqui filtro
                </div>

ent√£o dentro dessa div iremos adiciona um button e nesse button iremos atribuir  uma propriedade do bootstrap que abre um modal chamada data-bs-toggle='modal' data-bs-target='#filterModal'
dessa forma:
<div className='col-sm-1'>
                    <button data-bs-toggle='modal' data-bs-target='#filterModal'>
                        Filtros
                    </button>
                </div>




(crie titulo ou mini titulo)
tambem usamos um icone pro filtro, usamos a tag i para isso!
exemplo usado:
   <button className='btn btn-filtro d-flex float-end' data-bs-toggle='modal' data-bs-target='#filterModal'>
                       <i className='mdi mdi-filter-variant'></i>
                       filtro
                    </button>
 esse icone pegamos la do design icons como foi explicado anteriormente.
 
 
   
 (crie um mini titulo)
 para o modal do filtro aparecer, nos criamos um componente chamado ModalFilter.jsx que ir√° conter
 um modal com o bootstrap, e quando o bot√£o for clicado, exibirar esse componente.
 o modal nos pegamos la na parte de documento do bootrstrap, na parte de modal, e o escolhido foi esse:

exemplo: 
// Modal 
<div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="exampleModalLabel">Modal title</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        ...
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary">Save changes</button>
      </div>
    </div>
  </div>
</div>


e o nosso componente do modal ficou dessa forma:
import React from 'react'

export default function ModalFilter() {
  return (
    <div className="modal fade" id="filterModal" tabindex="-1" aria-labelledby="exampleModalLabel" aria-hidden="true">
  <div className="modal-dialog">
    <div className="modal-content">
      <div className="modal-header">
        <h1 className="modal-title fs-5" id="exampleModalLabel">Modal title</h1>
        <button type="button" className="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div className="modal-body">
        ...
      </div>
      <div className="modal-footer">
        <button type="button" className="btn btn-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" className="btn btn-primary">Save changes</button>
      </div>
    </div>
  </div>
</div>
  )
}


um detalhe importante:
na div principal  <div className="modal fade" id="#filterModal"
eu dei o id dela de filterModal, 
mesmo nome que dei pro data-bs-target do bot√£o do modal com o botstrap,
 <button className='btn btn-filtro d-flex float-end' data-bs-toggle='modal' data-bs-target='#filterModal'>



agora pra esse modal funcionar, normalmente iriamos importar ele no componente de categoria, mas 
iremos importar no nosso componente principal app, e em seguida fazer com que seja exibido, dessa forma:
//importar modal de filtro
import ModalFilter from './components/ModalFilter';

e agora so precisamos retornar esse componente no nosso componente app,
dessa forma:
function App() {
  return (
    <div>
      <Navbar />
      <Categorias />
      <ModalFilter />
    </div>
  )
}

       

pronto, com o componente modal ja funcionando ao clicar, (chat, n√£o sei pq funciona com o bot√£o ao clicar, acredito que seja por que esteja ligado ao id,
mas deie uma explica√ß√£o dando cntinuidade oque falei, 'ja funcionado ao clicar' ai voce continua, estando ligado balblabla e suas explica√ß√µes )
 

agora s√≥ precisamos dar o conteudo a esse modal.

(crie um titulo)
ao prencher o conteudo do modal, tera uma parte onde iremos precisar criar um componente 
pro price slics, basicamente √© a barra que movimentamos que vai filtrar os valores de pre√ßos, 
e √© ideial criamos um componente separado pois mantem uma maior organiza√ß√£o e controle das manipual√ß√£o das propriedades,
por que vamos ter que saber qual √© a categoria que ele est√° filteando, qual a faixa de pre√ßos, valor minimo e valor maximo,e tambem 
quando criamos um componente com react, o legal √© que quando temos ele prontos, possamos usar em diversos outtos projetos tambem,e alem disso,
essa quest√£o de prics slics e uma das coisas mais usadas em filtragem,√© um tipo de filtro muito usado como ecormece, e filtros que precisam filtrar valores.
(prices √© pre√ßo em ingles, e slider e como se fosse deslizar)

ent√£o criamos um componente dentro da pasta components chamado de priceSlier.jsx


(crie um mini titulo
com o componente criado, agora vou explicar sobre, esse ricslideer e como se fosse uma composi√£o de 4 elementos,
nos temos o slider, e como se fosse a barra cinza mais clara(disponibilizei a aimegm certinho na pasta de imagem),
que √© onde nossos itens v√£o poder deslizar, agente vai ter tambem, uma barra de progresso, vamos chamar de progress, que √© a barrinha mais escura,
√© a barrinha que vai acompanhando conforme os movmentos das bolinhas, e as duas bolinhas que movimentamos na verdade s√£o campos input do tipo renge,
e como se fosse aquelas de aumentar e diminuir volumes, pra puxar pro lado, mas so que com css modificado, e teremos o range minimo e o range maximo, e tudo isso alinhado com
o css pra parecer uma coisa s√≥, so  que √© uma montagem, vamos colocar varios itens dentro usando css pra fazer esse efeito,
e fazendo o uso do useStae, agente sabendo qual √© o valor minimo, qual o valor maximo, nos podemos fazer com que o componente se comporte dessa forma confoem nos mvimenta, a barra de progresso acompanha esse movimenta, e tambem
posso alimentar esses campinhinhos de pre√ßos minimos e pre√ßos maximos,
ent√£o vamos come√ßar fazendo a pasta estetica.

(crie mini titul)
ent√£o come√ßamos importando o css de slider no componente:
import './.css/priceSlider.css'

e em seguida damos uma classe chamada slider pra div do nosso componente,
esse slier ser√° a parte cinza que ter√° o deslizamento total dos nossos itens
exemplo:
import React from 'react'

import './.css/priceSlider.css'
export default function priceSlider() {
  return (
    <div>
      <div className='slider'> </div>
</div>
  )
}

o seu ccs √©:
.slider{
    display: flex;
    position: relative;
    height: 5px;
    background: #ddd;
    border-radius: 5px;
}
isso cria uma barra deslizante um pouco cinza. 
(explique melhor sobre esse codigo css)    


e dentro da div slider teremos outra div que sera a de progresso e 
a classse se chamara progress.
desa forma:
export default function priceSlider() {
  return (
    <div>
      <div className='slider'>
        <div className='progress'> </div>
        
      </div>
</div>
  )
}


essa barra de progresso √© a responsavel por fazer com que fique mais escuro ou mais claro,
mas isso sera feito de forma dinamica e ja chegamos la.


e o seu css √©:
.slider .progress{
    height: 100%;
    position: absolute;
    /* left:5%;
    right:30%; */
    background: #464646;
}

oque faz a nossa barra se movimentar √© esse position absolute,
por exemplo, se eu deixasse a sua esquerda de 5%, ele ja n√£o iria ficar colado na esquerda,
e agora com esse efeito, a barra de progreso fica mais escura.
(explique melhor esse codigo css tambem chat)



agora iremos precisar fazer as bolinhas que o usuario vai fazer a movimenta√ß√£o.
e pra isso vamos usar um truque muito interessante que √© com um tipo de input 
chamado range, e pra isso criamos uma div dentro de slider com a classe se chamada range-input,
e essa div sera um container que tera nossos campos input, e dentro dela teremos dois campos input
do type range. um input sera responsavel pelo o valor minim e o outro 
sera pelo o valor maximo, e iremos dar um id diferente pros dois.
exemplo do codigo:
export default function priceSlider() {
  return (
    <div>
      <div className='slider'>
        <div className='progress'> </div>
         <div className='range-input'>
         <input id='rangeMin' type='range' />  
         <input id='rangeMax' type='range' />  
        </div>
      </div>
</div>
  )
}



e nos iremos usar uma tecnica onde so usamos as bolinhas desse campo, essa tecnica oculta a barra e fica so com a bolinha de movimenta√ß√£o.

tecnica css:

.range-input{
    position: relative;
}

nos iremos dar o position realtive pro componente pai 
pra podermos manipulas os input com position abslute em relala√ß√£o
a a ele.

.range-input input{
    width: 100%;
    position: absolute;
    height: 5px;
    top:-5px;
    background: none;
    pointer-events: none;
    -webkit-appearance: none;
    -moz-appearance: none;
}

os campos do tipo input tera uma postion abslute, fazendo
com que os dois campos ja fiquem um em cima do outro no mesmo lugar,
nos tiramos o seu beckground com background none.
nos chamaos o -webkit-appearance: none; o -webkit-appearance √© um atributo que for√ßa 
o navegador tirar a aparencia padr√£o do nosso campo, e colocamos como none, fazendo com que suma com as barrinhas.
-moz-appearance: none; esse √© a mesma coisa pro outrom, so que esse √© pro firefox,
o outro e pro chrome, no safare e etc.
e com isso ficamos so com as bolinhas.
tambem passmmaos que eles ter√£o uma largura de 100%, para que v√£o at√© o final.
para a alinha dentro da barrinha do slider (tava um pouco abaixo),
usamos height: 5px ,mesma aulturua do nosso slider, 
e passamos que o top do postion absolute seja -5px, fazendo com que fique exatamente na linha do slider.
tambem usamos outro atributo chamado pointer-events: none;
quando usamos esse  -moz-appearance: como none, agente proibe do usuario podr movimentar essas bolinhas,
por que oque vai fazer essas bolinhas movimentaram ser√° a nossa barra de progresso,
ent√£o conforme nossa barra d eprogresso for deslizando, as blinhas elas v√£o deslizando tambem.







(crie um mini titulo)
agora iremos modificar a aparencia dessaas bolinhas,
passando no css o input com o seletor com o type do tipo range, e usamos um seletor chamado
webkit-slider-thumb e {}, isso e pra trabalhamos apenas com as bolinhas
exemplo css:

input[type="range"]::-webkit-slider-thumb{
    width: 30px;
    height: 30px;
    background: white;
    border:1px solid #ccc;
    border-radius:50%;
    box-shadow: 0 0 6px rgba(0,0,0, 0.05);
    pointer-events: auto;
    -webkit-appearance: none;
}

passamos que ela tera uma largura de 30px, widht:30px.
tera tambem uma altura de 30px, um   height: 30px;.
passamos que ela sera branca, background: white;.
 -webkit-appearance: none; passamos ele novamente por que 
 se n√£o passamos algunas altera√ß√µes como o fundo branco m√£o ira 
 aparecer por que ainda contiava com o adr√£o padronizado, ent√£o tiramos o seu padr√£o.
 colocamos uma borda de 1px solida um pouco clarinha pra emchergamos,
border:1px solid #ccc;.
e usmos border radius pra dar uma arrendondada, border-radius:50%;
e colocamos uma sobrinha com bx-shadow,  box-shadow: 0 0 6px rgba(0,0,0, 0.05);
e agora colocamos o pointer-events que desativamos no nosso input do tipo range,
pra quando a pessoa for mexer nele, dai sim ela poder fazer altera√ß√£o,
 pointer-events: auto; est√° como automatico para que a pessoa possa fazer o movimento das bolinhas


usamos o uso do webkit-slider-thumb que √© para o funcionamento de vageadores do tipo webkit, 
que seria o chrome, no ege, no safare.



e copiamos todo o codigo e determinamos tambem que ir√° funcionar no firefox passando
no lugar de webkit-slider-thumb por moz-range-thumb
exemplo css:
input[type="range"]::-moz-range-thumb{
    width: 30px;
    height: 30px;
    background: white;
    border:1px solid #ccc;
    border-radius:50%;
    box-shadow: 0 0 6px rgba(0,0,0, 0.05);
    pointer-events: auto;
    -moz-appearance: none;
}
e o uncio detalhe √© que trocamos tambem no codigo 
por -moz-appearance: none;



e agora  parte estetica da movimenta√ß√£o do slider j√° esta funcionando.







(crie um mini titulo).
agora iremos fazer a parte do pre√ßo minimo e do pre√ßo maximo:

para fazer isso iremos fazer no nosso componente de priceSlider ainda, logo
abaixo do container dos input range, iremos criar esses itens, criamos uma div com a clas row 
e criamos duas duas colunas com duas div, e a primeira div tera um labem com a classe text-muted 
(vai ficar tipo um cinzinha, bootstrap) e dentro desse label colocamos 
o pre√ßo minimo, e em bxio do label usamos inputs grups do bootstrap (pegamos la do ste oficial o input)
exemplo de como ficou o pre√ßo minimo:
<div className='row mt-4'>
                <div className='col'>
                    <label className='text-muted'>pre√ßo m√≠nimo</label>
                    <div class="input-group mb-3">
                        <span class="input-group-text" id="basic-addon1">R$</span>
                        <input id="inputMin" type="text" class="form-control" placeholder="Min" />
                    </div>
                </div>


agora s√≥ basta copiar o conteudo dessa div input e colarmos na div de valor maximo.

exemplo de pre√ßo maximo:
   <div className='col'>
                    <label className='text-muted'>pre√ßo m√°ximo</label>
                    <div class="input-group mb-3">
                        <span class="input-group-text" id="basic-addon1">R$</span>
                        <input id="inputMax" type="text" class="form-control" placeholder="Max" />
                    </div>
                </div>

a unica diferen√ßa √© que trocamos o valor do id para Max o texto do labem para pre√ßo m√°ximo,
e o placeholder para Max                




(crie um mini titulo ou um titulo).
essa foi toda a parte de estiliza√ß√£o do nosso filtro,toda a estetica agora iremos para  aparte 
logica e fazer com que realmente funcione.


(crie um titulo):
para que possamos ter o controle dos valores dos nossos campos, iremos fazer o
uso do useState, o estado do react, para sabermos qual √© o valor mino e o valor maximo, e tambem qual √© o posicionamento da nossa barra de progresso,
que fazer precisar conforme for deslizando a bolinha, sabermos a porcentagm de acordo do pre√ßo minomo e ¬¥pre√ßo maximo, que ela deve deslizar dentro do nosso slider
que √© esse cinza mais claro.

iremos fazer algunas altera√ß√µes no nosso campo tipo range pois
ele tem algunas atributos que v√£o ser muito importante na hora de fazermos o funcionamento 
do nosso projeto,s√£o atributos que ja vem nesse tipo de campo input.
 o primeiro √© o valor minimo, o 'min=' e o outro atributo √© o max= ent√£o quer dizer, o nosso
 range pode deslizar entre o valor minimo e o valor maximo e temps outro atributo chamado value=. que √© quando 
 que o nosso range est√° no momento e temos outro atributo chamado step= que √© quantos passos esse nosso range pode dar,
ent√£o se eu colocar step='1', ele ira fazer o mvimento de 1 a 1.

no momento, esses valores serao esses:
<input id='rangeMin' type='range' min='50' max='2000' step='1' o value nao tem pq sera definido de forma dinamica.
apesar de ter esses valores inicalmente, no final ser√° tudo defenido de forma dinamica.
esses atributos do tipo range, iremos querer que seja determinado pelo o nosso componente priceslider, ent√£o iremos fazer o uso das propriedades, dos props.
ent√£o la no modalFilter,onde temos o priceSlider sendo redenrizado nos iremos passar nos props como essas propriedades devem se comportar.
entao colocamos dessa forma:
<div className="modal-body">
  <section className='px-2 mb-4 border-bottom'>
  <span className='fs-4 fw-bold'>Faixa de Pre√ßo</span>
  <p className='text-muted'>O pre√ßo m√©dio por noite √© de R$ 730</p>
  <PriceSlider min={50} max={2000} step={1} />
  </section>
</div>

ent√£o passamos no nosso componente esses props, (detlahe, nos prps eu posso dar o nome que eu quiser, n√£o precisa ser o mesmo do campo input
, s√≥ coocamos o mesmo pra seguir um padr√ßao mesmo),
e la no componente princeSlider nos recemos esses props, passamos na fun√ß√£o props,
exemplo:
export default function priceSlider(props) {
(e aqui est√° o conteudo do filtro slider)
}

e agora fazemos com que os input receba os valores de forma dincamica:
passaos em cada propriedade dentro da sintaxe jsx props. e o valor do props.
exemplo feito:
<div className='range-input'>
<input id='rangeMin' type="range" min={props.min} max={props.max} step={props.step} />
<input id='rangeMax' type="range" min={props.min} max={props.max} step={props.step} />
</div>

dessa forma estamos pegando os valores de forma dinamica 
via propriedade com os props que determinamos os valores.



(crie um titulo)

agora iremos fazer pra saber quais s√£o s valores minimo e os valores maximos com o useState
e tambem vamos usar um pouco o useEffect.
primeiro iremos fazer a importa√ß√£o dos dois dentro do nosso componente priceSlider.
exemplo:
import { useState, useEffect } from 'react';



e agora iremos criar eles 
dentro do componente, antes de return().
criamos qual √© o pre√ßo min e passamos que ele vai inicializar com o props.min.
dessa forma:
const [min, setMin] = useState(props.min);

e agora criamos um estado para o valor maximo e fazemos a mesma coisa,
e passamos que ele ir√° receber a props.max.
exemplo:
 const [min, setMin] = useState(props.min);
    const [max, setMax] = useState(props.max);



e tambem iremos precisar fazer com que nossa barra de progresso se movimente,
ent√£o iremos precisar criar uns estados pra sabermos em quantos % ela vai est√°r deslocada.
ent√£o o primeiro estado sera o let e passamos que ele vai cabecar como 0%, colocamos como string mesmo
exemplo:
const [left, setLeft] = useState('0%');

e criamos um estado para a direita tambem que come√ßarar em 0%
exemplo:
const [left, setLeft] = useState('0%');
const [right, setRight] = useState('0%');

e esses estados ser√° usada para definir quais sao os posicionamentos do css da nossa barra de progresso.
ent√£o ao invez de usar um valor definido no css do position abslolute, iremos fazer isso de forma dinamica no nosso codigo,
no retorno da montagem do nosso componente.


ent√£o eu vou fazer um estilo incorporado na div com className progress,
e pra fazer um estilo incorporado abrimos a chaves do jsx e depois do css, assim, {{}},
e aqui definimos que a propriedade left do css vai recebero valor do left que √© o nosso estado left, e passamos que o right, que seria o position right,
vai receber o estado da direita .
exemplo de como ficou:
<div className='slider'>
<div style={{ left: left, right: right }} className='progress'></div>
</div>

dessa forma a barra ir√° come√ßar na posi√ß√£o 0 dos dois lados.



(crie mini titulo)
agora iremos determinar o valor dos nossos range.
entao iremos passar que o valor dos inputs ser√° o estado do valor min, e o estado do valor max.
exemplo usado:
<input id='rangeMin' type="range" min={props.min} max={props.max} value={min} step={props.step} />
<input id='rangeMax' type="range" min={props.min} max={props.max} value={max} step={props.step} />

ent√£o dessa forma o min se posicioa no come√ßo, o valor inicial, e o maximo la no final com seu valor inicial.


(crie um titulo)
apesr de colocamos o vaor minimo e maximo agora, aquele valor se torna apenas leitura quando se trabalha com react (professor disse com essas palavras mas n√£o sei oque siginificou, explica)
e as bolinhas n√£o ir√£o se movimentar, oque vai fazer essas bolinhas se movmentar, vai ser a abrra de progresso, que conforme for se mvimentando, vai arrastando essa bolinha.

para isso criamos um eventos chamado onChange (onChange siginifca quando ao mudar) e demtro da chamada do evento no input,
iremos chamar a fun√ß√£o changeRngeMIn para o input de valor minimo.
exempo:
<input id='rangeMin' onChange={changeRangeMin} type="range" min={props.min} max={props.max} value={min} step={props.step} />

e essa fun√ß√£o vai ser a responsavel por 



(crie um mini titulo)
agora vamos explicar sobre essa fun√ß√£o changeRngeMIn.
nos criamos a fun√ß√£o changeRngeMIn e recuperamos o evento do nosso campo input com (e) como parametro
uma coisa interresante que podemos nessa fun√ß√£o pra entendr oque ta acontecendo.
se colocamos um console.log o valor que est√° vindo desse campinho, ent√£o vamos passando dentro do console,
o e que e o nosso campo input que est√° sendo modificado,targht.value.
exemplo:
function changeRangeMin(e){
   console.log(e.targth.value);
}
e formos la na ro range do valor minimo e movimentar, abrindo o console iremos perceber que o valor desse input 
tambem ser√° mudado  , ele est√° modificando o valor o nosso range, apesar da bolinha n√£o est√° se movimentando, ele acompanha o valor,
ent√£o ele come√ßa em 50, e conforme for puxando pro ado, no console sera mostrado que ele vai auemtando



(crie um mini titulo)
ent√£o oque iremos pedir pra setar o nosso minimo com o nosso e.targth.value e a unica coisa que iremos fazer antes
e converter esse texto para inteiro, s√≥ para garantir que seja um numero.
exemplo: 
setMin(parseInt(e.target.value));

ent√£o agora cada vez que for arrastando, ele ira alterar o nosso minimo.



e quando temos uma altera√ß√£o do nosso estado, nos temos o uso do nosso useEffect, ent√£o passamos 
qual sera o efeito colateral quando o estado for alterado.

ent√£o iremos passar um useEffect com uma arrown funtion e passamos que oque vai acontecer
se oque foi modificado foi o min, dessa forma criamos um useEffect que sera ativado qaundo setamos o minimo com o valor que ta vindo do campo.
exemplo do useEffect usado:
 useEffect(() => {
        if (min == props.min) {
            document.getElementById('inputMin').value = props.min;
        } else {
            document.getElementById('inputMin').value = min;
        }
}, [min]);

(fa√ßa uma explica√ß√£o sobre esse useEffect, explique oque el ta fazendo e oque ta acontecendo)



dessa forma agora o valor j√° √© atualizado conforme movimentamos o valor minimo, 
porem ainda precisamos fazer com qe a barra de progresso acompanhe, a parte pretinha tem que acompanhar o movimento
da bolinha.

(crie um mini titulo)
para fazer isso, passamos dentro da fun√ß√£o changeRangeMin onde sendo essa a fun√ß√£o responsavel pela a 
modifica√ß√£o da bolinha, quando movimentamos o minimo, nos vamos fazer o seguinte:

     function changeRangeMin(e) {
        setMin(parseInt(e.target.value));
        if (min == props.min) {
            setLeft("0%");
        } else {
            var totalBarra = props.max - props.min;
            var qtsSteps = min - props.min;

            setLeft(((qtsSteps * 100) / totalBarra) + "%");
        }
    }


eexplica√ß√£o:
nos passamos que se o valor do minimo for igual igual a props.min, que √© o valor minimo,
agente vai setar a esquerda, usando o setLeft, sera 0%, ent√£o se o minimo
estiver com o valor minimo 50, a esquerda ser√° zerada.

se n√£o for o valor igual 50, vamos ter que fazer um calculo pra saber quando a
nossa barra vai ter que se deslocar em porcentagem.
racicionando, a barra tem 100%, e 100% tem o valor de 2 mil, mas o 100% dessa bara come√£ com o pre√ßo minimo de 50
ent√£o s√≥ precisamos passar na variavel, valor total o valor maximo - o valor minimo, e o resultado d√° 1950,
2 mil - 50 da isso, e esse ser√° o valor total de movimento que podemos da.
na segunda variavel calculamos qauntos passos que pode ser dados, ser√° o valor min - o props min

e em seguida passamos no setLeft() vamos passar quantos steps ainda temos vezes 100 divido pelo o total da barra concatenado com %


dessa forma a nossa barra ja acompanha o deslize do nosso slider 



(crie um mini titulo)
e agora copiamos tudo e e coloamos para fazer o maximo,
a unica diferen√£ √© que iremos trocar tudo que tem min para max e a variavel qtsSteps nos invertemos.
dessa forma:
function changeRangeMax(e) {
        setMax(parseInt(e.target.value));
        if (max == props.max) {
            setRight("0%");
        } else {
            var totalBarra = props.max - props.min;
            var qtsSteps = props.max - max;

            setRight(((qtsSteps * 100) / totalBarra) + "%");
        }
    }




    useEffect(() => {
        if (max == props.max) {
            document.getElementById('inputMax').value = props.max + "+";
        } else {
            document.getElementById('inputMax').value = max;
        }
    }, [max]);
 
e fazemos a chamada do evento onChange da fun√ß√£o changeRangeMx no inout de valor max.
exemplo:
 <input id='rangeMax' onChange={changeRangeMax} type="range" min={props.min} max={props.max} value={max} step={props.step} />
-->




