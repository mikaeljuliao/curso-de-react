<!--
Aula 14 ‚Äì Formul√°rios e Componentes Controlados


Diferen√ßas entre HTML e React nos formul√°rios:
Quando a gente vem do HTML puro para o React, algumas diferen√ßas aparecem:

1. for vira htmlFor:
. No HTML, usamos o atributo for no <label> para ligar o campo ao id do <input>.
. No React, como for √© uma palavra reservada do JavaScript, usamos htmlFor.

<label htmlFor="nome">Nome:</label>
<input id="nome" type="text" />


2. Fechamento das tags <input />:
. No HTML puro, voc√™ pode deixar <input> aberto.
. No React, como tudo √© JSX (baseado em XML), precisa fechar sempre:

<input type="text" />  
<input type="checkbox" />  

. Isso vale tamb√©m para img, br, etc.



3. Diferen√ßa com <select> e <textarea>:
. O <select> e o <textarea> j√° t√™m tag de abertura e fechamento, ent√£o 
    continuam do mesmo jeito que no HTML.

<select>
  <option>Op√ß√£o 1</option>
</select>

<textarea></textarea>



Componentes Controlados:
No HTML puro, quando voc√™ digita em um campo de formul√°rio (input, textarea, select), 
o pr√≥prio elemento guarda o valor digitado.

No React, trabalhamos de outro jeito:

. O estado (useState) do componente √© quem guarda o valor.
. O input s√≥ mostra o que o estado manda mostrar.
. Isso faz com que o React seja a √∫nica fonte da verdade (ou seja, o React sabe exatamente o 
que est√° escrito em cada campo, a cada tecla que voc√™ digita).


Exemplo b√°sico:

function Formulario() {
  const [nome, setNome] = React.useState("");

  function handleChange(event) {
    setNome(event.target.value); // atualiza o estado conforme digita
  }

  function handleSubmit(event) {
    event.preventDefault(); // impede o refresh
    alert("Nome enviado: " + nome);
  }

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="nome">Nome:</label>
      <input 
        id="nome" 
        type="text" 
        value={nome} 
        onChange={handleChange} 
      />
      <button type="submit">Enviar</button>
    </form>
  );
}


- Sua conclus√£o (e est√° certa ‚úÖ)

‚ÄúEnt√£o isso quer dizer que cada item do nosso formul√°rio vai ficar salvo 
no estado, onde vai ter o conte√∫do de cada um dos itens guardado na mem√≥ria 
do componente. Dessa forma podemos fazer alguma coisa enquanto a pessoa digita, 
ou ent√£o conseguir trabalhar com as informa√ß√µes dos inputs antes que seja 
enviado ao back end quando o usu√°rio clicar no bot√£o de enviar.‚Äù

Perfeito! üëè
√â exatamente isso:

. A cada digita√ß√£o o estado √© atualizado.
. Voc√™ pode usar esse estado para mostrar mensagens em tempo real, validar dados 
antes de enviar, ou at√© bloquear o bot√£o de enviar se algo n√£o estiver correto.
. Quando o usu√°rio clica em "Enviar", voc√™ j√° tem tudo no estado, pronto para ser 
mandado para a API/back-end.

üëâ Resumindo:
. No HTML os campos cuidam sozinhos de seu valor.
. No React os campos viram controlados pelo estado 
‚Üí isso d√° muito mais poder e controle.



Atualizando Objetos no State com Spread Operator:
Quando temos um formul√°rio com v√°rios campos (como cliente, dia, hor√°rio, wifi, etc.), 
normalmente guardamos todos eles em um √∫nico objeto dentro do useState.

Mas a√≠ surge uma quest√£o: como atualizar apenas um campo do objeto sem apagar os outros?
üëâ Para isso usamos o spread operator (...), que copia o objeto inteiro, e depois 
mudamos s√≥ o campo que queremos.

O c√≥digo explicado:
function FormReserva() {
  const [form, setForm] = React.useState({
    cliente: '',
    dia: '',
    horario: '',
    wifi: false,
    churrasqueira: false,
    piscina: false,
    obs: ''
  });

  const handleChange = (event) => {
    const auxForm = { ...form }; // 1Ô∏è‚É£ copiamos o objeto atual
    auxForm[event.target.name] =
      event.target.type === "checkbox"
        ? event.target.checked // 2Ô∏è‚É£ se for checkbox, usamos true/false
        : event.target.value;  // 3Ô∏è‚É£ se for input normal, usamos o texto digitado
    setForm(auxForm); // 4Ô∏è‚É£ atualizamos o estado com o objeto novo
  };
}

resalando algo importante:
1Ô∏è‚É£ se for numeros boleanos, true/false pegamos o valor com heckbox e n√£p value
2Ô∏è‚É£  se for input normal, usamos value para pegar o valor o texto digitado

campos do tipo checkbox trabalhamos com valores boleanos, se eu fosse tentar pegar o valor e n√£o passase
checkbox, ele iria me retornar o valor vazio

Passo a passo:

1. {...form} ‚Äì Copiando o objeto atual:

. O operador spread pega todas as chaves e valores atuais do objeto form e cria 
uma c√≥pia nova.
. Isso √© importante porque no React n√£o devemos modificar o estado diretamente.
. Exemplo: {...form} cria um novo objeto com os mesmos campos de form.


2. event.target.name ‚Äì Descobrindo qual campo mudou:

. Cada <input> do formul√°rio tem um atributo name.
. Esse name √© usado como chave dentro do objeto form.
. Exemplo: se o input for <input name="cliente" />, ao digitar algo nele, 
event.target.name ser√° "cliente".



3. event.target.value e event.target.checked:

. Para inputs de texto, event.target.value √© o que o usu√°rio digitou.
. Para checkboxes, precisamos usar event.target.checked, que retorna true ou false.


4. setForm(auxForm) ‚Äì Atualizando o estado:

. Chamamos o setForm passando o novo objeto atualizado.
. Isso faz o componente re-renderizar e mostrar os valores atualizados em tempo real.

Por que precisamos do event?

Sua d√∫vida √© muito boa üëè

. O event √© o objeto de evento que o React entrega para a fun√ß√£o quando algo acontece 
(nesse caso, quando o usu√°rio digita ou marca um checkbox).

.Dentro dele temos v√°rias informa√ß√µes √∫teis:

. event.target.name ‚Üí qual campo disparou o evento
. event.target.value ‚Üí o valor digitado (inputs de texto)
. event.target.checked ‚Üí estado do checkbox (true/false)

üëâ Se n√£o tiv√©ssemos o event, nossa fun√ß√£o n√£o teria como saber qual campo foi 
alterado nem qual valor atribuir.
Ou seja, o par√¢metro √© essencial para a comunica√ß√£o entre o input e o React.




Trabalhando com <textarea> e <select> no React:

Quando usamos formul√°rios no HTML puro, alguns elementos guardam o valor de 
forma diferente do que no React.

No React, como aprendemos antes, todos os campos devem ser controlados pelo estado 
‚Üí ou seja, precisamos ligar o campo ao state com value e onChange.

1. <textarea>

üîπ No HTML comum:
O conte√∫do de um <textarea> √© definido entre a tag de abertura e fechamento:

<textarea>
  Texto inicial
</textarea>


üîπ No React:
Isso n√£o funciona, porque o valor precisa vir de um atributo value, igual a um <input>.
Assim, conseguimos controlar o que aparece no campo diretamente pelo estado.

Exemplo:

class EssayForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: 'Escreva aqui seu texto inicial...'
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({ value: event.target.value }); 
    // atualiza o estado a cada digita√ß√£o
  }

  handleSubmit(event) {
    alert('Texto enviado: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Digite algo:
          <textarea 
            value={this.state.value} 
            onChange={this.handleChange} 
          />
        </label>
        <input type="submit" value="Enviar" />
      </form>
    );
  }
}


‚úÖ Repare: no React, sempre usamos value + onChange. Assim, o textarea funciona 
exatamente como um input type="text".


2. <select>

üîπ No HTML comum:
Para deixar uma op√ß√£o selecionada, usamos o atributo selected:

<select>
  <option value="laranja">Laranja</option>
  <option value="limao">Lim√£o</option>
  <option selected value="coco">Coco</option>
</select>


üîπ No React:
Em vez de usar selected em cada <option>, usamos um √∫nico value no <select>.
Isso facilita porque o estado controla tudo em um s√≥ lugar.

Exemplo:

class FlavorForm extends React.Component {
  constructor(props) {
    super(props);
    this.state = { value: 'coco' }; 
    // valor inicial j√° vem do state

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleChange(event) {
    this.setState({ value: event.target.value });
  }

  handleSubmit(event) {
    alert('Seu sabor favorito √©: ' + this.state.value);
    event.preventDefault();
  }

  render() {
    return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Escolha um sabor:
          <select 
            value={this.state.value} 
            onChange={this.handleChange}
          >
            <option value="laranja">Laranja</option>
            <option value="limao">Lim√£o</option>
            <option value="coco">Coco</option>
            <option value="manga">Manga</option>
          </select>
        </label>
        <input type="submit" value="Enviar" />
      </form>
    );
  }
}


‚úÖ Repare: n√£o existe selected em nenhuma <option>. Quem controla a 
op√ß√£o escolhida √© o estado (this.state.value).

3. Compara√ß√£o geral
Elemento	               HTML Puro	                React (controlado pelo estado)
input	             <input type="text">	            <input type="text" value={estado} onChange={...} />
textarea           	<textarea>Texto aqui</textarea>	    <textarea value={estado} onChange={...} />
select	            <option selected>	                <select value={estado}>...</select>

üëâ Ou seja: no React todos os campos usam value + onChange para se tornarem controlados.









Aula: Entendendo o Formul√°rio de Reserva no React feito na aula:

Esse c√≥digo cria um formul√°rio completo de reserva, onde cada campo 
(nome, dia, hor√°rio, adicionais, observa√ß√µes) √© controlado pelo React.

1. Estado inicial do formul√°rio
const [form, setForm] = React.useState({
  cliente: '',
  dia: '',
  horario: '',
  wifi: false,
  churrasqueira: false,
  piscina: false,
  obs: ''
})


‚û° Aqui criamos um estado chamado form, que √© um objeto com v√°rias propriedades.
Cada propriedade corresponde a um campo do formul√°rio.
. cliente ‚Üí campo de texto do nome.
. dia ‚Üí select (segunda, ter√ßa, etc).
. horario ‚Üí radio button (manh√£, tarde, noite).
. wifi, churrasqueira, piscina ‚Üí checkboxes (true/false).
. obs ‚Üí textarea (observa√ß√µes).

Ou seja, todo o formul√°rio est√° centralizado dentro de um √∫nico objeto no estado.



2. Atualizando os valores (handleChange):
const handleChange = (event) => {
  const auxForm = { ...form }; 
  auxForm[event.target.name] = event.target.type === "checkbox" 
    ? event.target.checked 
    : event.target.value;
  setForm(auxForm);
}


O que acontece aqui?

1. event ‚Üí √© o objeto que o navegador envia quando algo acontece no input.
Ele cont√©m v√°rias informa√ß√µes do campo, como:
. event.target.name ‚Üí o nome do campo (cliente, dia, wifi, etc).
. event.target.value ‚Üí o valor digitado ou selecionado.
. event.target.checked ‚Üí se o checkbox est√° marcado ou n√£o.

2. const auxForm = { ...form } ‚Üí copiamos o estado atual.
Isso √© necess√°rio porque no React n√£o podemos alterar o estado diretamente, precisamos criar uma nova c√≥pia modificada.

3. auxForm[event.target.name] = ... ‚Üí

. Usamos event.target.name para identificar qual campo foi alterado.
. Se for um checkbox, usamos event.target.checked (true/false).
. Caso contr√°rio (input, select, textarea), usamos event.target.value.

4. setForm(auxForm) ‚Üí atualizamos o estado com a nova c√≥pia.

‚úÖ Isso garante que cada digita√ß√£o, clique ou sele√ß√£o atualize o objeto form corretamente.

3. Enviando o formul√°rio
const enviarForm = (e) => {
  e.preventDefault(); // impede o refresh da p√°gina

  console.log(form);  // mostra no console todos os dados do formul√°rio

  // aqui poder√≠amos:
  // - mandar para o back-end via API
  // - validar campos obrigat√≥rios
  // - exibir mensagens para o usu√°rio
}


‚û° Quando o usu√°rio clica em ‚ÄúFAZER RESERVA‚Äù, essa fun√ß√£o √© chamada.

. O preventDefault() impede o comportamento padr√£o (que seria recarregar a p√°gina).
. Podemos usar o form (que j√° tem todos os valores salvos no estado) como quisermos.


4. Como o JSX do formul√°rio usa o handleChange:

Cada campo chama handleChange no evento onChange.

Exemplos:

Input de texto (nome do cliente)
<input 
  onChange={handleChange} 
  name="cliente" 
  type="text" 
  className="form-control" 
  placeholder="Digite aqui" 
  required 
/>


. O atributo name="cliente" conecta o input √† chave cliente no estado.
. Quando o usu√°rio digita, handleChange atualiza form.cliente.

Select (dia da semana)
<select onChange={handleChange} name="dia" className="form-select" required>
  <option value="">Selecione o dia</option>
  <option value="segunda">Segunda</option>
  ...
</select>


. O name="dia" conecta ao form.dia.
. A op√ß√£o escolhida √© salva automaticamente no estado.


Radio buttons (hor√°rio)
<input 
  onChange={handleChange} 
  type="radio" 
  name="horario" 
  value="Manh√£" 
  required 
/>


. Todos t√™m o mesmo name="horario".
. Assim, o React entende que eles atualizam a mesma chave (form.horario).
. O value de cada radio indica se √© "Manh√£", "Tarde" ou "Noite".



Checkboxes (adicionais)
<input 
  onChange={handleChange} 
  name="wifi" 
  type="checkbox" 
/>

. Cada checkbox tem um name diferente (wifi, churrasqueira, piscina).
. O handleChange identifica que √© um checkbox e guarda true ou false.


Textarea (observa√ß√µes)
<textarea 
  onChange={handleChange} 
  name="obs" 
  placeholder="Deixe sua mensagem"
></textarea>

. O texto digitado vai direto para form.obs.



5. Visualizando o estado em tempo real:

Se descoment√°ssemos o useEffect:

React.useEffect(() => {
  console.log(form);
}, [form]);


‚û° Toda vez que o estado mudasse (o usu√°rio digitou, marcou, trocou op√ß√£o...), o objeto form seria exibido no console.
Isso ajuda muito a entender como os campos est√£o sendo salvos no estado.



6. Resumindo o fluxo

. O usu√°rio digita ou seleciona algo.
. O onChange chama handleChange.
. handleChange copia o estado, altera a propriedade correta e atualiza.
. O estado form guarda todos os valores atuais do formul√°rio.
. No envio (enviarForm), temos tudo pronto para validar, mostrar ou enviar para o back-end.

üëâ Esse exemplo √© muito bom porque mostra:

. Como lidar com diferentes tipos de inputs (texto, select, radio, checkbox, textarea).
. Como usar um objeto no estado para organizar todos os campos.
. A import√¢ncia do event para capturar name, value e checked.
. Como transformar o formul√°rio em um componente controlado.
-->

<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aprendendo React</title>
    <!-- REACT VERSION 17.0.2-->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <link rel="stylesheet" href="index.css">
    <!-- CSS only -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-iYQeCzEYFbKjA/T2uDLTpkwGzCiq6soy8tYaI1GyVh/UjpbCx/TYkiZhlZB6+fzT" crossorigin="anonymous">

</head>

<body>
    <div id="root"></div>
    <!-- JavaScript Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.1/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-u1OknCvxWvY5kfmNBILK2hRnQC3Pr17a+RTT6rIHI7NnikvbZlHgTPOOmMi466C8"
        crossorigin="anonymous"></script>
    <script src="app.js" type="text/babel"></script>
</body>

</html>